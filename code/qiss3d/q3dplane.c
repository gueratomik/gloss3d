/******************************************************************************/
/*  GLOSS3D is free software: you can redistribute it and/or modify           */
/*  it under the terms of the GNU General Public License as published by      */
/*  the Free Software Foundation, either version 3 of the License, or         */
/*  (at your option) any later version.                                       */
/*                                                                            */
/*  GLOSS3D is distributed in the hope that it will be useful,                */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/*  GNU General Public License for more details.                              */
/*                                                                            */
/*  You should have received a copy of the GNU General Public License         */
/*  along with GLOSS3D.  If not, see http://www.gnu.org/licenses/.            */
/******************************************************************************/

/******************************************************************************/
/*                                                                            */
/*  Copyright: Gary GABRIEL - garybaldi.baldi@laposte.net - 2012-2020         */
/*                                                                            */
/******************************************************************************/

/******************************************************************************/
/*                                                                            */
/* Please avoid using global variables at all costs in this file, and never   */
/* forget this :                                                              */
/*                         Keep It Simple Stupid !                            */
/*                                                                            */
/******************************************************************************/
#include <config.h>
#include <qiss3d/q3d.h>

/******************************************************************************/
/*** From http://www.siggraph.org/education/materials/HyperGraph/raytrace/  ***/
/*** rayplane_intersection.htm                                              ***/
/******************************************************************************/
float q3dplane_intersectLine ( Q3DPLANE    *qpla, 
                               Q3DLINE     *qlin, 
                               Q3DVECTOR3F *qpnt ) {
    float vo = ( qpla->x * qlin->src.x ) +
               ( qpla->y * qlin->src.y ) +
               ( qpla->z * qlin->src.z ) + qpla->w,
          vd = ( qpla->x * qlin->dir.x ) + 
               ( qpla->y * qlin->dir.y ) +
               ( qpla->z * qlin->dir.z );
    uint32_t ret;
    float t;

    if ( vd == 0.0f ) return 0.0f;

    t = - ( vo / vd );

    if ( t > 0.0f ) {
        qpnt->x = qlin->src.x + ( qlin->dir.x * t );
        qpnt->y = qlin->src.y + ( qlin->dir.y * t );
        qpnt->z = qlin->src.z + ( qlin->dir.z * t );

        return t;
    }

    return 0.0f;
}

/******************************************************************************/
float q3dplane_intersectSegment ( Q3DPLANE    *qpla, 
                                  Q3DVECTOR3F *pnt0,
                                  Q3DVECTOR3F *pnt1,
                                  Q3DVECTOR3F *qpnt ) {
    Q3DLINE qlin = { .src = { .x = pnt0->x,
                              .y = pnt0->y,
                              .z = pnt0->z },
                     .dir = { .x = pnt1->x - pnt0->x,
                              .y = pnt1->y - pnt0->y,
                              .z = pnt1->z - pnt0->z } };
    float vo = ( qpla->x * qlin.src.x ) +
               ( qpla->y * qlin.src.y ) +
               ( qpla->z * qlin.src.z ) + qpla->w,
          vd = ( qpla->x * qlin.dir.x ) + 
               ( qpla->y * qlin.dir.y ) +
               ( qpla->z * qlin.dir.z );
    uint32_t ret;
    float t;

    if ( vd == 0.0f ) return 0.0f;

    t = - ( vo / vd );

    if ( ( t > 0.0f ) && ( t < 1.0f ) ) {
        qpnt->x = qlin.src.x + ( qlin.dir.x * t );
        qpnt->y = qlin.src.y + ( qlin.dir.y * t );
        qpnt->z = qlin.src.z + ( qlin.dir.z * t );

        return t;
    }

    return 0.0f;
}

/******************************************************************************/
/*** plane type is Q3DVECTOR3F because the w member is unneeded ***/
void q3dplane_getRandomPoint ( Q3DVECTOR3F *qpla,
                               Q3DVECTOR3F *qsrc,
                               float        radius,
                               Q3DVECTOR3F *qpnt ) {
    static float 
    randn[256] = { -0.9985, -0.9973, -0.9958, -0.9887, -0.98, -0.9758, -0.9747, -0.9656, -0.965, -0.9371, -0.9352, -0.9303, -0.9003, -0.8999, -0.8908, -0.889, -0.882, -0.8592, -0.8552, -0.8339, -0.8331, -0.8315, -0.7974, -0.7959, -0.7895, -0.7871, -0.7831, -0.7804, -0.7803, -0.7732, -0.7698, -0.7601, -0.7578, -0.7505, -0.7491, -0.7473, -0.7416, -0.7353, -0.7336, -0.7307, -0.7287, -0.7283, -0.726, -0.7248, -0.7205, -0.7151, -0.7116, -0.6963, -0.6868, -0.6799, -0.6779, -0.676, -0.6757, -0.6732, -0.6687, -0.6634, -0.6533, -0.6447, -0.6217, -0.6209, -0.6043, -0.6003, -0.5948, -0.5871, -0.5867, -0.5681, -0.5542, -0.5477, -0.5434, -0.5121, -0.5107, -0.461, -0.4419, -0.4321, -0.4258, -0.4203, -0.4198, -0.4128, -0.3868, -0.3801, -0.3771, -0.3745, -0.354, -0.3489, -0.3409, -0.3254, -0.3232, -0.3073, -0.2902, -0.2835, -0.2812, -0.2633, -0.2627, -0.2573, -0.2511, -0.2231, -0.2189, -0.2189, -0.2159, -0.2011, -0.2006, -0.1993, -0.1966, -0.1726, -0.1681, -0.1537, -0.1467, -0.1166, -0.1144, -0.1127, -0.1077, -0.1049, -0.0928, -0.0855, -0.0819, -0.0802, -0.0736, -0.0707, -0.0675, -0.0599, -0.0536, -0.0481, -0.0439, -0.0424, -0.0304, 0.006, 0.0137, 0.0174, 0.0213, 0.0397, 0.0487, 0.0547, 0.0584, 0.0613, 0.0651, 0.0698, 0.0812, 0.1124, 0.1233, 0.1525, 0.1799, 0.1916, 0.2072, 0.2079, 0.2093, 0.2129, 0.2181, 0.2318, 0.2421, 0.2757, 0.2858, 0.2888, 0.2934, 0.294, 0.2962, 0.3017, 0.3174, 0.3258, 0.3406, 0.344, 0.3521, 0.3528, 0.3695, 0.3696, 0.3849, 0.3852, 0.3921, 0.3992, 0.3996, 0.4067, 0.4087, 0.4097, 0.4105, 0.4164, 0.4497, 0.454, 0.4666, 0.4823, 0.4852, 0.4903, 0.4916, 0.5035, 0.5053, 0.5299, 0.5309, 0.5315, 0.5321, 0.5378, 0.548, 0.5486, 0.5552, 0.5571, 0.5576, 0.5669, 0.5789, 0.583, 0.5857, 0.5914, 0.6052, 0.6066, 0.609, 0.6148, 0.6213, 0.6252, 0.6335, 0.6428, 0.647, 0.6511, 0.6599, 0.6752, 0.6769, 0.6991, 0.7039, 0.7212, 0.7325, 0.7435, 0.7515, 0.7779, 0.7806, 0.7879, 0.7946, 0.7951, 0.7953, 0.81, 0.8125, 0.8224, 0.8277, 0.8339, 0.8423, 0.8475, 0.8487, 0.8621, 0.8628, 0.873, 0.8759, 0.8825, 0.8848, 0.8882, 0.8937, 0.8958, 0.908, 0.9179, 0.9197, 0.9201, 0.9277, 0.9325, 0.9369, 0.9389, 0.9531, 0.9582, 0.9606, 0.9619, 0.9655, 0.9776, 0.9804, 0.9815 },

    reach[256] = {
         0.8006f, 0.4322f, 0.1648f, 0.9842f, 0.0373f, 0.6186f, 0.8403f, 0.7799f,
         0.2385f, 0.8160f, 0.6531f, 0.2744f, 0.8210f, 0.3843f, 0.2982f, 0.3982f,
         0.7460f, 0.2266f, 0.6426f, 0.2220f, 0.6567f, 0.7642f, 0.9396f, 0.8490f,
         0.2078f, 0.6890f, 0.2080f, 0.9677f, 0.2619f, 0.0572f, 0.2561f, 0.9362f,
         0.3880f, 0.7008f, 0.4034f, 0.5201f, 0.6110f, 0.5886f, 0.8670f, 0.2127f,
         0.1097f, 0.4445f, 0.1462f, 0.6551f, 0.4121f, 0.7749f, 0.2761f, 0.4357f,
         0.7679f, 0.9934f, 0.9929f, 0.9104f, 0.5261f, 0.6362f, 0.5053f, 0.2310f,
         0.5492f, 0.3842f, 0.9679f, 0.0286f, 0.6080f, 0.3684f, 0.0049f, 0.2516f,
         0.5677f, 0.9478f, 0.1150f, 0.1284f, 0.5699f, 0.2422f, 0.1554f, 0.9493f,
         0.2448f, 0.0614f, 0.0862f, 0.2992f, 0.4980f, 0.1639f, 0.3291f, 0.6929f,
         0.7417f, 0.4179f, 0.4308f, 0.1670f, 0.2795f, 0.3207f, 0.9303f, 0.1427f,
         0.7368f, 0.8005f, 0.3268f, 0.4872f, 0.9861f, 0.2242f, 0.2015f, 0.0427f,
         0.4703f, 0.3208f, 0.7121f, 0.6789f, 0.3727f, 0.2606f, 0.6528f, 0.0693f,
         0.9181f, 0.7797f, 0.5968f, 0.3310f, 0.1912f, 0.1526f, 0.2255f, 0.1224f,
         0.3578f, 0.3029f, 0.9667f, 0.4605f, 0.5388f, 0.8967f, 0.7122f, 0.2809f,
         0.6632f, 0.4217f, 0.6668f, 0.0265f, 0.7139f, 0.3289f, 0.8941f, 0.6786f,
         0.4419f, 0.8466f, 0.2122f, 0.2193f, 0.7541f, 0.2525f, 0.6921f, 0.4220f,
         0.5167f, 0.3143f, 0.7661f, 0.9109f, 0.9323f, 0.6999f, 0.0124f, 0.9240f,
         0.4955f, 0.5430f, 0.9030f, 0.0403f, 0.6829f, 0.7969f, 0.3196f, 0.2994f,
         0.8864f, 0.3687f, 0.1349f, 0.5128f, 0.1158f, 0.8775f, 0.6436f, 0.8100f,
         0.2099f, 0.4705f, 0.4126f, 0.5217f, 0.9340f, 0.9398f, 0.3231f, 0.1963f,
         0.7561f, 0.4726f, 0.4632f, 0.9604f, 0.4243f, 0.6127f, 0.1755f, 0.0550f,
         0.1073f, 0.2950f, 0.5637f, 0.6396f, 0.5304f, 0.3760f, 0.6641f, 0.9108f,
         0.0990f, 0.1890f, 0.1277f, 0.0908f, 0.7007f, 0.8328f, 0.3524f, 0.8587f,
         0.5203f, 0.1224f, 0.0105f, 0.0353f, 0.9273f, 0.3824f, 0.1071f, 0.4691f,
         0.2692f, 0.3590f, 0.6420f, 0.5008f, 0.0826f, 0.9639f, 0.7874f, 0.5977f,
         0.5209f, 0.0591f, 0.6055f, 0.9243f, 0.9554f, 0.3219f, 0.7363f, 0.4321f,
         0.4098f, 0.2339f, 0.7689f, 0.1499f, 0.4883f, 0.7616f, 0.0408f, 0.6186f,
         0.2398f, 0.7162f, 0.5395f, 0.0190f, 0.4926f, 0.4030f, 0.4008f, 0.9037f,
         0.3039f, 0.0185f, 0.1917f, 0.7023f, 0.9909f, 0.2896f, 0.7966f, 0.8168f,
         0.4666f, 0.8659f, 0.9834f, 0.5545f, 0.2567f, 0.5037f, 0.9494f, 0.8622f,
         0.2624f, 0.6179f, 0.0904f, 0.5948f, 0.9291f, 0.3018f, 0.0180f, 0.1479f };
    int xindex = rand() % 256,
        yindex = rand() % 256,
        rindex = rand() % 256; /*** because why not ***/
    Q3DVECTOR3F perpendicular = { .x = reach[xindex],
                                  .y = reach[yindex],
                                  .z = 0.0f };

    perpendicular.z = - ( ( perpendicular.x * qpla->x ) +
                          ( perpendicular.y * qpla->y ) ) / qpla->z;

    q3dvector3f_normalize ( &perpendicular, NULL );

    qpnt->x = qsrc->x + ( perpendicular.x * randn[rindex] * radius );
    qpnt->y = qsrc->y + ( perpendicular.y * randn[rindex] * radius );
    qpnt->z = qsrc->z + ( perpendicular.z * randn[rindex] * radius );
}
